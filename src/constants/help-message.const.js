/* node:coverage disable */
import { DefaultEmptyFlasksNumber } from './default-empty-flasks-number.const.js';
import { FlaskCapacity } from './flask-capacity.const.js';
import { MaxEmptyFlasksNumber } from './max-empty-flasks-number.const.js';
import { SpotsInRunNumber } from './spots-in-run-number.const.js';
import { pluralPipe } from '../utils.js';

/**
 * Текст справки
 * @constant {string}
 */
export const HelpMessage =
`Я по картинке решаю игру с сортировкой цветных объектов по колбам\\.

Просто отправьте мне скриншот колбочек \\(изображением или файлом\\)\\. Я определю цветные пятна на скриншоте, спрошу, какие из них являются объектами в колбах, и пришлю решение\\.

*Чуть подробнее*
Скриншот можно прислать изображением или файлом\\. Отправка файлом \\(то есть без сжатия\\) снижает вероятность ошибок при определении цветных пятен\\.

На скриншоте я буду искать цветные пятна\\. После нахождения я буду нумеровать их по ${SpotsInRunNumber} на изображении, присылать его и спрашивать, какие из них являются объектами в колбах\\. Пронумерованные ранее также будут отмечены\\. Если такие есть среди пронумерованных в этот раз, их номера нужно отправить мне\\. При этом, если номера идут подряд, можно указать первый и последний, а между ними поставить дефис\\. Помимо этого между числами и дефисами можно вставлять любые символы, они будут проигнорированы\\. Например, запись 1 2 4\\-7 означает, что пятна под номерами 1, 2, 4, 5, 6, 7 — искомые\\. После каждой партии я буду спрашивать, есть ли на изображении ещё искомые объекты\\. Если есть необходимость пропустить ответ \\(например, в этой партии нет искомых объектов\\), можно просто прислать любое сообщение, не содержащее цифр и дефисов\\.

Я сформирую указанные пятна в колбы и покажу результат\\. После этого я задам 2 вопроса: какое искать решение и в каком формате его присылать\\.

Решений есть 3 вида: решение, которе ищется быстро, но может состоять из большого количества ходов, решение, которое ищется значительно дольше, но состоит из наименьшего количества ходов, и решение, которое ищется так же быстро, как в первом методе, или быстрее, и состоит из наименьшего или почти наименьшего количества ходов\\.

Форматов решения есть 2 вида: я могу прислать изображение колб для каждого хода или список из пар, где первый элемент — номер колбы, из которой нужно перелить, а второй — номер колбы, в которую нужно перелить\\.

*Правила игры*
Изначально есть несколько колб\\. Каждая колба вмещает ${FlaskCapacity} ${
  pluralPipe(FlaskCapacity, [ 'слой', 'слоя', 'слоёв' ])
}\\. Каждый слой имеет свой цвет\\. В начале игры слои в колбах расположены в случайном порядке\\. Нужно, имея ${DefaultEmptyFlasksNumber} ${
  pluralPipe(DefaultEmptyFlasksNumber, [ 'пустую колбу', 'пустые колбы', 'пустых колб' ])
}, найти такую последовательность переливаний, чтобы все ${FlaskCapacity} ${
  pluralPipe(FlaskCapacity, [ 'слой', 'слоя', 'слоёв' ])
} в каждой колбе были одного цвета и каждая колба была либо пустой, либо заполненной\\.
Переливать можно только на слой такого же цвета или в пустую колбу\\.
Иногда найти решение с ${DefaultEmptyFlasksNumber} ${
  pluralPipe(DefaultEmptyFlasksNumber, [ 'пустой колбой', 'пустыми колбами', 'пустыми колбами' ])
} невозможно\\. Тогда есть возможно увеличить количество пустых колб вплоть до ${MaxEmptyFlasksNumber}\\.

В любой непонятной ситуации можете писать мне: \\@tmible`;
/* node:coverage enable */
